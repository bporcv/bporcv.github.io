<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F0.html</url>
    <content type="text"><![CDATA[Hadoop安装[TOC] 下载https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/stable/ 单机模式 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 集群模式]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F0.html</url>
    <content type="text"><![CDATA[Jenkins使用pipline构建Maven项目[TOC] 拉取Git远程仓库以上代码非常简单,通过使用git关键字,配置credentialsId和url后Jenkins就可以拉取远程git仓库代码了.Url很好理解,即为远程仓库的地址.这里比较费解的是credentialsId是什么,如何设置它?其实也非常简单,前面讲自由式任务的时候我们讲过如何在jenkins里添加添加一个git用户名和密码,这里的credentialsId即为我们创建的包含用户名和密码的用户信息的id(这个id是jenkins自动生成的)这里通过这个id,Jenkins便可以找到这个用户名和密码. 创建一个用户名和密码要创建一个用户名和密码也不是非常复杂,我们在Jenkins主面板左侧导航面板里找到Credentials,点击进入,便可以看到以下一个面板 这里左侧Credentials下面有一个System我们点击一下,此时面板中央位置如下图 我们点击这个链接进入,此时左侧会出现一个添加Credentials按钮 点击便会出现一个可以设置用户名和密码的界面 如上图示,Kind使用默认的,添加一个用户名和密码.然后添加用户名和密码,此时id可以手输入,如果留空则Jenkins会自动生成一个.Description为一个简短描述,用户名和密码很多时方便区分. 添加成功后我们想要看到这条记录的id,点击板右侧的搬手螺丝刀图标就可以看到id了.我们把这个id复制到 PipeLine里credentialsId 添加一个ssh key使用用户名和密码容易泄密,实际工作中常常使用ssh方式登陆,这里对如何生成ssh key,如何在远程仓库中添加公钥不再赘述,不熟悉的童鞋可以参考前面章节或者官方帮助文档以及在互联网上搜索相关材料.这里介绍下如何把ssh 私钥添加到Jenkins里,以便Jenkins使用ssh连接远程仓库. 添加私钥类似以上添加用户名密码,只是添加用户名密码时Kind选项使用的是默认的选择,这里Kind下拉一下,选择SSH username with private key,用户名即为你的git账户用户名,private key勾选Enter directly把我们本机的私钥添复制到框里面. 需要注意的是ssh和http地址是不一样的,一定要注意. 把代码拉到指定位置Jenkins默认会的把项目拉到Jenkins安装目录下Workspace+项目名的目录下面,很多时候由于一些原因我们可能希望改变这一行为,把项目拉到自定义的一个目录下面,这时候可以使用dir函数,然后把要执行的代码写在dir函数代码块内.示例代码如下 node{ stage(&quot;check out&quot;){ dir(&quot;projdir&quot;){ git credentialsId: &#39;3c210def-c000-4e2a-9b2d-838986a6b172&#39;, url: &#39;https://github.com/mrtylerzhou/gitShow.git&#39; } } } 以上语句执行后,可以看到jenkins会把代码拉到Workspace+项目名+projdir的目录下,当然也可以指定绝对路径. 拉取指定分支的代码 node { stage(&#39;Source&#39;) { git branch: &#39;master&#39;, credentialsId: &#39;GitHubAccess&#39;, url: &#39;https://github.com/cookcodeblog/my-private-project.git&#39; } }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F0.html</url>
    <content type="text"><![CDATA[Java安装[TOC] 获取安装包百度网盘： 链接：https://pan.baidu.com/s/1FO_YHabi7vmRLL3dZZMrxw提取码：fka2 上传并解压安装包将下载的安装包上传到服务器，可以用过xftp上传，或者rz命令（需要提前安装lrzsz，yum install lrzsz） 本安装包目录：/home 设置环境变量软件安装目录：/usr/local/java 移动解压后的软件包到软件安装目录 mv jdk1.8.0_131/ /usr/local/java 编辑/etc/profiles文件，添加java环境变量到文件末尾 export JAVA_HOME=/usr/local/java export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 使环境变量生效 source /etc/profiles 验证安装结果，输入以下命令查看结果，如果当前终端没生效，请重新打开个终端窗口 javac]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础语法]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FJava%2Fea538f2a.html</url>
    <content type="text"><![CDATA[Java基础语法[TOC] 注释 单行注释 // 单行注释 多行注释 /* 多行注释 第一行注释 第二行注释 */ 文档注释 标识符关键字数据类型数据转换常量变量运算符包机制JavaDoc]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的数据类型]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FJava%2F9af728b5.html</url>
    <content type="text"><![CDATA[Java中的数据类型]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java开发环境搭建]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FJava%2F77a3ba8f.html</url>
    <content type="text"><![CDATA[Java开发环境搭建[TOC] 开发环境版本 操作系统: Windows10 Java : 1.8.141 开发IDE: IDEA 2020.1.2 Git: 2.27.0 Java环境搭建下载java要想使用java，需要进行java开发环境的搭建，在Win10的基础上，我们需要下载java安装包，并配置系统环境变量，有以下几种方式进行下载安装。 官网地址： https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 下载地址： https://www.oracle.com/webapps/redirect/signon?nexturl=https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-windows-x64.exe 依旧系统版本选择对应的java进行下载，因为现在下载都需要注册账号了，如果不想注册账户或者网速过慢，可以从我的网盘中进行下载 链接：https://pan.baidu.com/s/1tFNCcjAQWBR2AxnG0hZi7A提取码：i3rv 安装Java双击下载的软件安装包即可，会出现下述界面，点击下一步，进入下一步的安装 选择安装位置，记住安装的位置，等下要用，建议不要装到中文路径下，然后点击下一步 进入安装环节，等待安装完成，接下来会弹出jre的安装界面，点击下一步 同样记住jre的安装目录，点击下一步 jre安装进度，等待jre安装完成 安装完成后会出现如下界面，然后直接关闭即可。 关闭上述窗口后，安装过程也就算了完成了。 配置环境变量以管理员身份打开cmd窗口输入javac命令，如果如下图所示，则说明没有配置好环境变量 需要配置如下环境变量，打开win10的控制面板 点击系统，点击之后找到高级系统设置 点击高级系统设置，选择环境变量 在系统变量下面，选择新建如下系统变量 新建JAVA_HOME（之前JDK安装的目录） C:\Program Files\Java\jdk1.8.0_251 新建CLASSPATH（检查jar包的调用） 下面的值为固定值，前面有.符号，结尾有分号，直接拷贝即可 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 编辑path系统变量 新建如下两条路径 %JAVA_HOME%\bin %JAVA_HOME%\jre\bin 配置完成后一路确定就ok了。 验证环境变量为了防止cmd终端缓存，需要关闭之前的窗口，新打开个窗口，再次输入javac命令，如果出现如下所示的说明，即说明环境变量配置成功了，就可以进行java的开发了。 我们还可以通过java -version，命令来查看安装的版本是否正确。 到此，java环境就搭建完成了，java开发环境还需要在IDEA中进行配置才行。 Java开发搭建在IDEA中配置Java第一种，在初始界面选择Configure，然后选择Structure for New Project，然后设置jdk版本 设置jdk版本为我们刚才安装的版本， 还有语言等级，如果有多个版本，选择自己喜欢的就好。 设置完成后即可 第二种，新建项目的时候设置 选择新建项目 选择java项目，选择JDK版本，选择Next 设置项目信息，如果出现下面的步骤，直接跳过，这里就是创建一个简单的java程序，点击Next 输入项目名称，点击Finish即可，如果出现提示框，可以直接点击OK 编写一个HelloWorld程序，进行测试，测试OK，Java开发环境就搭建OK了]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java简介]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FJava%2F9c4b5cef.html</url>
    <content type="text"><![CDATA[Java简介]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Html入门]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2FHtml%2Fc154aecc.html</url>
    <content type="text"></content>
      <categories>
        <category>前端</category>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flume安装]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FFlume%2F10339de6.html</url>
    <content type="text"><![CDATA[Flume定义Flume是Clodera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合、传输的系统.Flume基于流式架构，灵活简单。 Flume最主要的作用就是：实时读取服务器本地磁盘的数据，将数据写入到第三方中间件中，比如HDFS，Kafka等。 基础架构 AgentAgent是一个JVM进程，它以事件的形式将数据从源头运至目的地。 Agent主要有3个部分组成，Source，Channel，Sink。 SourceSource是负责接收数据到Flume Agent的组件。Source组件可以处理各种类型、各种格式的日志，包括avro，thrift，exec，jms，spooling directory，netcat，sequence generator，syslog，http，legacy。 SinkSink不断地轮询Channel中的事件且批量地移除它们，并将这些事件批量写入到存储或索引系统，或者被发送到另一个Flume Agent. Sink组件目的地包括hdfs，logger，avro，thrift，ipc，file，HBase，solr，自定义。 ChannelChannel是位于Source和Sink之间的缓存区。因此，Channel允许Source和Sink运作在不同的速率上。Channel是线程安全的，可以同时处理几个Source的的写入操作和几个Sink的读取操作。 Flume自带三种Channel：Memory Channel和File Channel，以及Kafka Channel。 Memroy Channel是内存中的队列。Memory Channel在不需要关心数据丢失的情境下适用。如果需要关心数据丢失。那么Memory Channel就不应该使用，因为程序死亡、机器宕机或者重启都会导致数据丢失。 File Channel将所有事件写入磁盘。因此在程序关闭或机器宕机的情况下不会丢失数据。 Event传输单元，Flume数据传输的基本单元，以Event的形式将数据从源头送至目的地。Event由Header和Body两部分组成。Header用来存放该event的一些属性，为K-V结构，Body用来存放该条数据，形式为字节数组。 安裝部署安装地址 Flume官网地址 http://flume.apache.org 文档地址 http://flume.apache.org/releases/content/1.7.0/FlumeUserGuide.html 下载地址 http://archive.apache.org/dist/flume/ 安装部署入门案例]]></content>
      <categories>
        <category>中间件</category>
        <category>Flume</category>
      </categories>
      <tags>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git工作区，暂存区，本地版本库，远程版本库]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2Fc31fe0f0.html</url>
    <content type="text"><![CDATA[基本概念区域转换图工作区暂存区本地版本库远程版本库区域工作流程文件的四种状态文件的状态转换图实战演练]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建第一个仓库并配置Local用户信息]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2Ff55b47bd.html</url>
    <content type="text"><![CDATA[工欲善其事必先利其器 经过Git简介与安装以及Git配置文件作用域及最小可用配置讲解，我们已经为Git的准备做足了功课。下面我们将来介绍如何创建第一个仓库并利用之前的学习到的Git配置文件的作用域来指定本仓库的配置。 实验环境 Windows10 Git 2.9.0 新建第一个Git仓库使用以下步骤可以新建一个Git仓库 进入系统中某个盘，本文进入G盘，读者可相应的改变 新建一个文件夹，保证新建的文件夹内无任何文件，包括隐藏文件 执行git init命令即可初始化一个Git仓库 由于本Git系列的文章都是通过使用GitBash来对命令进行操作的。所以上述步骤转换为命令操作即是： # git命令进入盘符采用这种方式，类似于Linux的目录结构 cd /g # 在G:盘下新建一个目录git-learning mkdir git-learning # 切换到git-learning目录下，即进入git-learning目录 cd git-learning # 开始使用git命令了，git status 标识查看当前目录下是否存在一个仓库 git status # 如果出现[fatal: Not a git repository (or any of the parent directories): .git]提示 # 说明不存在仓库，使用git init命令初始化仓库，执行完后会有如下提示： # [Initialized empty Git repository in G:/git-learning/.git/] git init # 再次查看当前目录是否存在一个git仓库， git status 如果你已经执行了上述的命令，并且执行结果如下图所示，图中也对每一句代表了什么信息做了详细的解释说明。那么恭喜你，你已经成功的初始化了一个仓库。 配置仓库级别（Local）的用户信息Git中的配置文件作用域已经在上一讲中做出了说明，如果有不明白的可以去看Git配置文件作用域及最小可用配置讲解，那么这里将证明一下Git配置的作用域，将配置global级别和local级别的作用域配置，采用最小配置，即：user.name以及user.email，分别使用以下配置（这里只做模拟说明使用，具体请读者按照需求配置）： global user.name：globalUser user.email：`globalUser@gmail.com` local user.name：localUser user.email：`localUser@gmail.com` 新增配置执行以下命令即可完成配置 git config --global user.name globalUser git config --global user.email globalUser@gmail.com git config --local user.name localUser git config --local user.email localUser@gmail.com 如果像下面的截图一样，没有任何输出，那么恭喜你，配置成功了 查看配置配置完成后，我们来查看配置是否采用了就近原则 可能通过上图你说，你怎么知道用local就是这个仓库的配置文件呢，那么我先剧透一下，git本仓库的配置文件位于当前仓库根目录下的.git/config文件中，在本例因为仓库位于G:/git-learning/目录下，所以，这个完整的配置文件路径就是G:/git-learning/.git/conf，那么让我们查看一下这个文件，来证明我们这个是对的，当然，知道了文件的位置，那么就可以手动编辑，要知道语法哦，简单分析一下就知道了，这里就不在赘述了。 更新配置更新配置很简单，只需要运行前面新增配置中的命令即可，git就会帮你覆盖掉之前的配置，下面做个简单的演示，将local的user.name修改为localUserUpdate 删除配置这里说一下删除配置项的原因，因为git不会帮你检查你输入的配置项是否正确，那么我们很可能输入错误，比如将user.name输错成user.mame，那么git也是给我们提供了删除配置的命令，这个命令就是： git config --unset 你的配置信息 下面演示一下： 命令拾遗当我们不知道一个命令怎么用的时候，我们可以直接在git中输入这个命令，就会给我们提示，如我们输入git config命令，git的人性化的提示信息就出现了，关于这块，后面会专门出一篇如何使用git的提示信息的博文，敬请期待]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA多线程学习笔记 —— 线程的简介与入门]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FJava%2F5169e384.html</url>
    <content type="text"><![CDATA[[TOC] 理论知识为什么会出现多线程多线程出现的主要原因 科学技术的发展。计算机从早期的巨型机到微型机，从早期的单核CPU到现在的多核CPU，从单核CPU的伪多线程到现在多核CPU的真正意义上的多线程，以及取决于决定性因素的CPU处理能力与程序运行的高度不匹配都是促使多线程出现的原因之一， 贪婪之心。人是串行化的动物（神童，天才，超能力者除外），一次只能做一件事，当然，只要给与足够的时间，同时交给你的任务总是能够采用串行化的方式执行完，不知道这是不是996的由来。人虽然不能，但是计算机可以，计算机并行执行的能力相较于人类同时处理多种事情导致的上下文切换，更能保证正确性。 充分利用资源。我们都知道CPU的运行速度是很快的，计算机在执行非CPU型任务，比如：读取文件，写数据到数据库，此时CPU是空闲的，但是却会因为程序是串行化（非多线程程序）的执行，而导致CPU得不到很好的利用，其实，此时CPU本可以做其他事情的，如继续读取其他的指令进行执行。这样也能充分的利用CPU资源，高效的完成任务。 串行与并行在上面我们提到了串行，并行的概，那么什么是串行，什么是并行。在程序的世界里，串行和并行主要是指程序任务的执行方式。 串行 多个任务时，各个任务按顺序执行，完成一个之后才能执行下一个。 并行 多个任务时，多个任务可以同时执行 举个简单的例子用来理解上面的概念： 每个人或多或少都有过去窗口打饭的经历，那么当只有一个窗口的时候，如果你想吃饭怎么办呢，只好排队对吧，因为窗口只有一个，那么当你前面的的人在没有打饭完成之前，你都只好等着，等你前面的人依次排队把饭打完才能轮到你打饭对吧，这就是串行，排队式，一个接一个的执行，只有前一个执行完成才能轮到你的执行。打饭打了很多天了，结果每天都会因为有很多人因为等的时间比出去找个新地方吃饭的时间要长而选择离开，而你是最能忍的，你觉得还可以接受，主要是饭菜可口，但是食堂老板不接受啊，这跑的可都是钱呀，他进行调研之后仔细一算，决定再开一个窗口，来提高食堂供应饭菜的速度，这样同一时间内就能提供两份饭菜了，从前丢失的顾客又再次投入了老板的怀抱，老板开心的笑了。其实这里的增设窗口就是并行的处理了顾客等待时间的问题，提供了一种能力，一种能够同时供应两个用户的就餐能力。 针对上面的问题，我们会在下面通过实战模拟来体会一下串行和并行。 Java中的多线程很多人在使用java中的多线程的时候总是搞不清楚某些概念，而导致使用不好多线程。首先要能够区分的概念我认为是线程对象和线程的概念，相信来学线程的，一定是对java基础还是有一定了解的，我们常常一说线程就会说Thread，很多人就会认为Thread就是一个线程，真的是这样吗?显然不是这样，这是一个认知的误区，那么我们来分析下到底什么是线程，什么是线程对象 线程对象 线程对象，顾名思义——持有线程的对象。那么在JAVA中，是谁呢，没错，就是我们的Thread对象，无论你是直接new出来的Thread对象，还是其子类的实例化，只要在没有执行它的start()方法，那么这个对象就可以称之为线程对象，它只是持有这个线程的引用，并没有通过你的new方法创建了一个线程。 线程 如果仔细理解了上面线程对象的概念，那么就不难理解这里的线程的概念，只有当我们显示的调用了这个线程对象的start()方法时，才能称之为真正的创建了一个线程，那么这个线程是怎么创建的呢，这就和操作系统有关了，JAVA会通过调用本地方法 start0()来再操作系统中开辟线程的生存空间，从而创建一个我们理解意义上的线程。 如果上述概念已经澄清了，那么我们就可以学习JAVA中线程的实现方式了。 实现方式 声明一个类继承自Thread，并重写其run()方法 声明一个类实现Runnable接口，实现其run()方法，将其作为Thread的参数来创建线程 实战将会上面描述的窗口打饭进行描述，用于达成以下目的 理解串行和并行 理解线程对象和线程 使用线程 体会线程下面我们创建一个线程对象，然后启动这个线程，查看执行结果 创建线程方式一： 声明一个类继承自Thread，并重写其run()方法 public class TaskThread extends Thread { // run()方法是线程的主要业务执行单元 @Override public void run() { System.out.println(&quot;我是TaskThread，我的任务就是执行一系列的任务&quot;); } public static void main(String[] args) { /*======================================继承方式创建一个线程=========================*/ /** * 这里仅是声明了一个线程对象，并没有实际的创建出一个线程 */ TaskThread taskThread = new TaskThread(); /** * 这里是将线程对象变成一个线程的方法，如果注释这行，启动程序的时候讲不会打印`我是一个线程， * 新创建的哦`这句话。由于线程的执行需要CPU的调度，而不是调用的start方法后就立即执行 */ taskThread.start(); /*======================================内部类方式创建========================*/ // 采用内部类方式创建，如果不重写run方法，则什么也不会输出 Thread thread = new Thread() { @Override public void run() { System.out.println(&quot;我是一个线程，新创建的哦。&quot;); } }; thread.start(); System.out.println(&quot;main方法执行结束&quot;); } } 创建线程方式二： 声明一个类实现Runnable接口，实现其run()方法，将其作为Thread的参数来创建线程 public class TaskRunnable implements Runnable { @Override public void run() { System.out.println(&quot;我是通过Runnable方式创建的线程哦&quot;); } public static void main(String[] args) { // 创建一个线程对象，使用实现了Runnable接口的对象作为参数 Thread thread = new Thread(new TaskRunnable()); // 线程对象启动，成为一个线程 thread.start(); System.out.println(&quot;main方法结束了哦&quot;); } } 一个窗口点餐（串行）code清单1 /** * @ClassName SingleWindowOrderFood * @Description 单个窗口点餐 * @Author Administrator * @Date 2019/10/11 22:56 * @Version 1.0 */ public class SingleWindowOrderFood { public static void main(String[] args) { System.out.println(&quot;到饭点了，大家可以开始排队点餐了&quot;); long start = System.currentTimeMillis(); // 窗口一： 处理50人的用餐 for (int i = 0; i &lt; 50; i++) { try { // 这里模拟一个人点餐需要1秒，那么50个人点餐就需要50s Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;一个窗口，每人耗时1秒，50人点餐，执行总共耗时：&quot; + ((System.currentTimeMillis() - start) / 1000) +&quot;s&quot;); } } 通过运行上述的代码，我们可以发现，程序一共跑了50s 可能有人会写出下面的代码，心想：不就是两个窗口吗，我写两个循环不就完了，分别处理25个客户请求： public class DoubleWindowsOrderFood { public static void main(String[] args) { System.out.println(&quot;到饭点了，大家可以开始排队点餐了,今天两个窗口哦&quot;); long start = System.currentTimeMillis(); // 窗口一： 处理25人的用餐 System.out.println(&quot;窗口一点餐开始&quot;); for (int i = 0; i &lt; 25; i++) { try { // 这里模拟一个人点餐需要1秒，那么25个人点餐就需要25s Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;窗口一点餐结束&quot;); System.out.println(&quot;窗口二点餐开始&quot;); // 窗口二： 处理25人的用餐 for (int i = 0; i &lt; 25; i++) { try { // 这里模拟一个人点餐需要1秒，那么25个人点餐就需要25s Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;窗口二点餐结束&quot;); System.out.println(&quot;两个窗口，每人耗时1秒，50人点餐，执行总共耗时：&quot; + ((System.currentTimeMillis() - start) / 1000) + &quot;s&quot;); } } 执行结果： 其实这个的执行结果和上面单个窗口的执行结果是一样的，那么我们来分析一下为什么？很简单，程序是串行化的，也就是一行一行执行的，并没有做到并行化执行，他不会从窗口一就直接跳到窗口二的代码去，只能一行一行的执行，一行一行的出结果，所以这里执行的结果都是一样的，都会耗费50s 并行化改造站在生活的角度，两个窗口肯定是同时提供服务的，而不是必须等一个执行完了，才开始第二个，我们需要真正意义上的贴近生活的设计，那么线程就是用来干这个事的，下面我们对代码进行改造一下。 public class OrderFoodConcurrency { public static void main(String[] args) { System.out.println(&quot;到饭点了，大家可以开始排队点餐了,今天两个窗口哦，这里并行点餐哦&quot;); Thread windowOne = new Thread(){ @Override public void run() { long start = System.currentTimeMillis(); System.out.println(&quot;窗口一开始点餐了&quot;); // 窗口一： 处理25人的用餐 for (int i = 0; i &lt; 25; i++) { try { // 这里模拟一个人点餐需要1秒，那么25个人点餐就需要25s Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;窗口一点餐耗时：&quot; + ((System.currentTimeMillis() - start) / 1000) + &quot;s&quot;); } }; windowOne.start(); Thread windowTwo = new Thread(){ @Override public void run() { long start = System.currentTimeMillis(); System.out.println(&quot;窗口二开始点餐了&quot;); // 窗口二： 处理25人的用餐 for (int i = 0; i &lt; 25; i++) { try { // 这里模拟一个人点餐需要1秒，那么25个人点餐就需要25s Thread.sleep(1_000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;窗口二点餐耗时：&quot; + ((System.currentTimeMillis() - start) / 1000) + &quot;s&quot;); } }; windowTwo.start(); try { // 这里让main方法睡眠30s，主要是为了验证整个程序的执行时间，当然在后面会有来统计线程 // 执行时间的方法,这里就不做讲解了，其实main方法也是执行在一个线程中的，名字就叫main线程，这点 // 我们会在后面解析,因为窗口一和窗口二同时执行，那么最少需要25秒的时间才能完成两个线程的执行， // 这里我们睡眠30s，足矣，不然main线程启动完两个线程后直接挂掉了，无法监视时间 Thread.sleep(30_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;所有窗口按照预期都执行完了点餐&quot;); } } 执行结果： 分析 由于窗口一和窗口二是并行执行的，所以理论上两个线程完美状态是共耗时25s]]></content>
      <categories>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka安装]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FKafka%2F89340871.html</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习笔记]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FKafka%2Fb1bf01c2.html</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yum更换镜像源]]></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2FLinux%2FCentOS%2F3c238fc5.html</url>
    <content type="text"><![CDATA[CentOS 7更换国内镜像源阿里源备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 更新下载新的CentOS-Base.repo 到/etc/yum.repos.d/ CentOS 6wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo CentOS 7wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 生成缓存yum makecache]]></content>
      <categories>
        <category>运维</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Cent OS</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《软件安装入门到卸载系列》]]></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2FLinux%2FCentOS%2F6b1b7458.html</url>
    <content type="text"><![CDATA[Cent OS 7.xErlang安装yum更换镜像源]]></content>
      <categories>
        <category>运维</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Cent OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Erlang的安装与卸载]]></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2FLinux%2FCentOS%2Fe03cc139.html</url>
    <content type="text"><![CDATA[CenOS 7.x准备工作erlang官网下载地址：https://www.erlang.org/downloads erlang solutions 地址：https://www.erlang-solutions.com/resources/download.html 安装wget工具 yum install wget yum方式安装官方文档地址：https://www.erlang-solutions.com/resources/download.html 添加存储库条目wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm rpm -Uvh erlang-solutions-1.0-1.noarch.rpm 如果在执行rpm -Uvh erlang-solutions-1.0-1.noarch.rpm的时候报错 执行以下命令,然后重新执行rpm -Uvh erlang-solutions-1.0-1.noarch.rpm yum install epel-release 安装Erlangyum install erlang 验证安装结果erl -version 安装成功界面如下图所示]]></content>
      <categories>
        <category>运维</category>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Cent OS</tag>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMWare安装CentOS7虚拟机]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FVMWare%2F4a5e8db3.html</url>
    <content type="text"><![CDATA[VMware14安装CentOS7安装环境说明 Windows10 64位 VMware® Workstation 14 Pro CentOS-7-x86_64-Minimal-1611.iso 安装步骤 选择创建新的虚拟机 选择自定义创建虚拟机 选择Workstation14.x，点击下一步 选择安装程序光盘映像文件，然后点击下一步 选择虚拟机安装名称和位置 设置虚拟机处理器和内核数，机器性能好的可以往上选，这里用默认的就行，然后点击下一步 设置虚拟机内存，依旧视自己的电脑配置而定，这里使用默认推荐的内存1G，够用了，点击下一步 设置网络，这里使用默认的NAT网络制式就可以了，然后下一步 设置I/O控制器类型，这里使用默认的，点击下一步 设置磁盘类型，选择默认的，点击下一步 选择磁盘，使用默认的，选择下一步 指定磁盘容量，看需求和机器配置，这里使用20G就可以了，设置完后点击下一步 设置创建的虚拟机磁盘文件名，也就是虚拟机的打开文件，以后迁移，克隆用到的。 创建完成，点击完成，之后自动安装开启。 进入CentOS安装界面，选择安装CentOS,Install CentOS Linux 7这个选项，然后就开始安装了，鼠标出入Vmware使用Ctrl + Alt 进入语言选择界面，选择语言，依据需求选择，点击Continue 配置系统安装项，因为这里使用的是最小化安装，所以SOFRWARE SELECTION里面什么都没有，可以设置DATE &amp; TIME和KEYBOARD制式等，还有NETWORK &amp; HOSTNAME等。配置结束后点击Begin Installation 设置root用户密码和用户认证 这里建议设置root密码，然后可以使用root帐号登录，免去授权的麻烦，另外，如果密码较弱，按照提示点击两次Done即可。然后等待安装结束。 等待安装结束，重启，完成安装 输入帐号密码，如果能进入系统，恭喜你，安装成功了。]]></content>
      <categories>
        <category>工具</category>
        <category>VMWare</category>
      </categories>
      <tags>
        <tag>VMWare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ SpringCloud实战]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2F1a80a0df.html</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ SpringBoot实战]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2F93e9b7c4.html</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ_Java实战]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2F617fec18.html</url>
    <content type="text"></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ简介与安装]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2Fa4560bed.html</url>
    <content type="text"><![CDATA[RabbitMQ简介与安装简介安装WindowsCentOS 7在安装RabbitMQ之前，必须安装和RabbitMQ版本相匹配的Erlang/OTP。Erlang和RabbitMQ的对应关系可以看下面这个网址：https://www.rabbitmq.com/which-erlang.html 安装Erlang参考 Erlang安装 安装RabbitMQ 选择目录cd /home 下载rabbitMQwget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.18/rabbitmq-server-3.7.18-1.el7.noarch.rpm 安装yum install rabbitmq-server-3.7.18-1.el7.noarch.rpm 设置开机启动chkconfig rabbitmq-server on 启用Web管理插件查找rabbitmq-server的安装目录 vi /usr/lib/systemd/system/rabbitmq-server.service 其中ExecStart和ExecStop就是命令行工具的目录，就是rabbitmq-sercer的命令目录，找到后进去目录 cd /usr/sbin ./rabbitmq-plugins enable rabbitmq_management 启用成功的标识 重启rabitmq服务systemctl restart rabbitmq-server 关闭防火墙/开放端口15672关闭防火墙 systemctl stop firewalld 开放端口 firwall-cmd --zone=public --add-port=15672/tcp --permanent 添加用户进入rabbitmq命令目录，或者直接使用rabbimqctl全局命令 cd /usr/sbin 执行添加用户命令，并授予administrator权限，可用于登录Web管理界面 ./rabbitmqctl add_user admin 123456 ./rabbitmqctl set_user_tags admin adminsitrator ./rabbitmqctl list_users 登录Web界面，验证 #####]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《RabbitMQ学习笔记》]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2Fe6c0ec84.html</url>
    <content type="text"><![CDATA[RabbitMQ学习笔记目录01_RabbitMQ简介与安装02_RabbitMQ_Java实战03_RabbitMQ_SpringBoot实战04_RabbitMQ_SpringCloud实战]]></content>
      <categories>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql安装]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMysql%2Fbdf2ca90.html</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[准备开发环境]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FSpringCloud%2F6d3e0eb2.html</url>
    <content type="text"><![CDATA[本教程的所有示例都统一使用以下环境配置 Windows 10IDEA 2018.2 UltmiateMaven 3.5.0Git 2.9.0SpringBoot 2.0.1SpringCloud Dalston.SR1 关于Maven的安装使用说明请参考博主的《Maven实战》系列的 下载与安装Maven 关于Git的安装使用说明请参考博主的《白话Git》 关于IDEA的使用说明请参考博主的《编程利器——IDEA》]]></content>
      <categories>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud简介]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FSpringCloud%2F4dd766a2.html</url>
    <content type="text"></content>
      <categories>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《疯狂SpringCloud 微服务架构实战》学习笔记目录]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2FSpringCloud%2F4dd766a2.html</url>
    <content type="text"><![CDATA[01_SpringCloud简介02_准备开发环境03_SpringCloud组件——Eureka04_SpringCloud组件——]]></content>
      <categories>
        <category>后端</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三分钟利用Github配合Hexo搭建博客]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FHexo%2F1092497b.html</url>
    <content type="text"><![CDATA[安装Git安装NodeJs申请账号]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置文件作用域及最小可用配置讲解]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2F85076309.html</url>
    <content type="text"><![CDATA[[TOC] 工欲善其事必先利其器 这章呢，讲解下Git的配置，通过这些配置，我们能更好的使用Git这个神兵利器。想开始使用Git，也不是没有条件的，Git存在一个最小化的配置，只有配置了这个最小配置，我们就能开始使用Git了，至于其他的相关配置项会在后面的文章进行介绍。 实验环境 Windows10 Git 2.9.0 Git的最小配置git config --global user.name &#39;yourname&#39; git config --global user.email &#39;youremail&#39; 配置解释第一点：作用域 global ：global意指全局作用域，即在没有配置其他作用域的情况下，当前系统登录用户所建的所有仓库的配置信息 第二点：配置项 user.name：使用仓库的用户的用户名 user.email：使用仓库的用户的用户邮箱 之所以会配置这两项之后就能开始对Git的使用了，是因为人性化的考虑，在Git的使用中，无论是单人使用，还是团队使用，user.name以及user.email能够准确的对每一次Git的提交做出标记，能够标记出：是谁在什么时候，做了什么提交，如果出现问题，或者写的太棒了，我想联系他，那么该通过什么方式来联系，没错，就是那个邮箱了。这种设计是一种对提交记录的追踪，对代码贡献度的统计，对代码bug的追踪甩锅等等，都是Git设计哲学中不可或缺的一部分。 下面来看一下到底global代表了什么，即Git的配置作用域。 配置作用域在Git的配置哲学中，配置的作用域分为三种：系统级别（system），全局级别(global)，仓库级别(local)。 系统级别（system） 定义 什么是系统级别的配置呢，系统级别的配置就是上面所说的针对系统下的所有用户的所有仓库使用同一种配置文件。其约束范围是系统中所有用户的所有仓库 作用域 系统中的所有用户的所有仓库 配置文件位置 windows 如果你找不到，没关系，教你一招，输入以下命令，就出来了 git config --system -e Linux 一般是/etc/gitconfig 全局级别（global） 定义 全局级别的配置是系统下的当前登录用户的所有仓库使用同一种配置文件。其约束范围是当前登录用户的所有仓库 作用域 当前登录用户的所有仓库 配置文件位置： Windows C:/User/[你的用户目录]/.gitconfig Linux ~/.gitconfig 仓库级别（local） 定义 仓库级别的配置是当前仓库使用的配置文件。其约束范围是当前配置文件所在仓库 作用域： 具体配置的仓库 配置文件位置： Windwos 仓库目录/.git/config Linux 仓库目录/.git/config 注意事项 无论是在Windows中还是Linux中.git目录是个隐藏文件夹，在Windows中需要打开隐藏文件才能看到，Linux中可以使用命令查看，可以尝试ls -al，视操作系统而定，如若不行，则需要自行百度。 配置优先级在Git的三种配置文件的优先级，按照就近原则，即 仓库级别 &gt; 全局级别 &gt; 系统级别，即便系统级别的配置了相关配置项，那么我只要在全局级别中进行了配置，就以全局配置的配置项为准，同样的，即便你在全局级别的配置中配置了相关配置项，那么只要我在仓库级别进行了配置，就以仓库级别的为准。 进行了上述的最小配置后，我们就可以正式的开始使用Git了。]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编程利器——IDEA》]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FIDEA%2Fa44a05a2.html</url>
    <content type="text"><![CDATA[工欲善其事必先利其器 IDEA 01_IDEA简介与安装02_Git简介与安装]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODO]]></title>
    <url>%2F%E8%AE%A1%E5%88%92%2FPlan%2F6c9b5b14.html</url>
    <content type="text"><![CDATA[TODO1 TODO2]]></content>
      <categories>
        <category>计划</category>
        <category>Plan</category>
      </categories>
      <tags>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《ElasticSearch笔记》]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FElasticSearch%2Fa8882e14.html</url>
    <content type="text"><![CDATA[目录ElasticSearch核心知识01_什么是ElasticSearch02_ElasticSearch的03_Java中的数据类型 ElasticSearch运维优化ELK]]></content>
      <categories>
        <category>中间件</category>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《白话系列之-Git》]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2Fa44a05a2.html</url>
    <content type="text"><![CDATA[工欲善其事必先利其器 Git作为当前最流行的版本控制工具，以其分布式，独特的分支管理方式闻名于众多开发者心中，是目前主流的版本管理工具，我们所熟知的全球闻名的同性交友社区Github就是依赖Git而打造的。依赖Git的设计哲学，也衍生出了很多好用的工具，如Github，Gitlab，码云等代码托管平台，也造就了SourceTree，Git客户端等强大的图形化界面，但是真正的高手都是通过黑窗口和命令来提现出自己的不凡，同样这也是客户端所不能带来的高度自由的用户体验。本系列将以白话文的形式来对Git设计哲学进行解读，对其原来的概念，理论，命令，配合以实战的方式来进行说明，分为以下几章，循序渐进，由浅入深，一一道来。 01_Git简介与安装01_Git简介与安装]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简介与安装]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2FGit%2Fa21830fd.html</url>
    <content type="text"><![CDATA[工欲善其事必先利其器 说道软件的安装，作为程序员，简单点分，就两平台：Windows，Linux平台，如果细分的话，可能就是Windows]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写作计划]]></title>
    <url>%2Funcategorized%2F89edd5a9.html</url>
    <content type="text"><![CDATA[创建这个文件的目的是为了更好的给自己所掌握的知识进行归类，也是更好的来确定自己未来的方向，我也希望自己能够在未来三到五年内，在技术上做些沉淀，然后往管理方向发展，这个主要是更改自己的性格缺陷和多看多观察别人的管理方式。 目录命名规范 0X –&gt; 归属于前端学习路径和顺序 00 –&gt; HTML 01 –&gt; CSS 02 –&gt; JavaScript 03 –&gt; Vue 04 –&gt; React 1X –&gt; 归属于后端学习路径和顺序 10 –&gt; Java 11 –&gt; Mysql 12 –&gt; Spring 13 –&gt; SpringMVC 14 –&gt; Mybatis 2X –&gt; 归属于其他进阶学习框架 20 –&gt; SpringBoot 21 –&gt; SpringCloud 22 –&gt; ElasticSearch 23 –&gt; Canal 24 –&gt; Nginx 25 –&gt; Redis 3X –&gt; 归属于开发过程中的工具和其他记录 30 –&gt; Git 31 –&gt; IDEA 32 –&gt; Eclipse 4X –&gt; 归属于运维 41 –&gt; CentOS 42 –&gt; Jenkins 43 –&gt; Docker 5X –&gt; 归属于其他语言的学习记录 50_Python 51_Shell 6X –&gt; 其他杂记 60_Hexo 61_LeetCode 62_Other]]></content>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
